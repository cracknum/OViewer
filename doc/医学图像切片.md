
# ä¸€ã€åŒ»å­¦å›¾åƒæ‰«ææˆåƒ

## 1.1 ä¸–ç•Œè½´
åœ¨åŒ»å­¦å›¾åƒä¸­ï¼ŒDICOMå›¾åƒçš„åæ ‡ç³»ç±»å‹ä¸ºLPS(Left/Posterior/Superior)ï¼Œåæ ‡åŸç‚¹ç”±å™¨æ¢°å‚å•†å›ºå®šï¼ˆåæ ‡åŸç‚¹ä¸éœ€è¦å…³å¿ƒï¼Œå› ä¸ºæˆ‘ä»¬æœ‰æ¯ä¸€å¼ sliceçš„ImagePositionPatientæ¥æŒ‡å®šsliceçš„åŸç‚¹ä½ç½®ï¼Œç”±ImageOrientationPositionæŒ‡å®šæ–¹å‘ï¼‰ï¼Œç”±åæ ‡åŸç‚¹å’ŒLPSåæ ‡ç³»ç»„æˆçš„å°±æ˜¯ä¸–ç•Œè½´ã€‚

## 1.2 frame of reference

frame of referenceæ˜¯ä¸€ä¸ªæ ‡è¯†ï¼Œç”¨äºæ ‡è¯†åœ¨åŒä¸€åæ ‡ç³»ä¸‹çš„seriesï¼Œåªæœ‰åœ¨åŒä¸€frame of referenceä¸­çš„seriesæ‰èƒ½ä¸ç»è¿‡é…å‡†ç›´æ¥æ”¾ç½®åˆ°ä¸€èµ·ï¼Œå¦åˆ™éœ€è¦å¯¹æ•°æ®é…å‡†å®Œæˆåæ‰èƒ½æ”¾ç½®åˆ°ä¸€èµ·ã€‚

## 1.3 å›¾åƒç´¢å¼•åæ ‡ç³»(I/J/K)è½¬ä¸–ç•Œåæ ‡ç³»(X/Y/Z)

åœ¨æ‰«æç»“æœçš„å±€éƒ¨åæ ‡ç³»ä¸‹ä¹Ÿå°±æ˜¯ç´¢å¼•åæ ‡ç³»ä¸‹æˆ‘ä»¬æˆ‘å¯ä»¥é€šè¿‡(i,j,k)è®¿é—®æ¯ä¸€ä¸ªä½“ç´ ï¼ˆæ³¨æ„ï¼Œä½“ç´ çš„å€¼å¹¶ä¸æ˜¯åœ¨è§’ç‚¹ï¼Œè€Œæ˜¯åœ¨ä½“ç´ çš„ä¸­å¿ƒä½ç½®ï¼Œæ‰€æœ‰è§’ç‚¹åº”è¯¥éšåˆ°ä½“ç´ ä¸­å¿ƒè¡°å‡ï¼‰ï¼Œä½†æ˜¯åœ¨ä½¿ç”¨æ•°æ®æ—¶æˆ‘ä»¬éœ€è¦å°†æ•°æ®è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»ä¸‹ï¼Œä¹Ÿå°±æ˜¯æ‚£è€…åæ ‡ç³»ä¸‹ï¼Œå¯¹åœ¨ä¸€ä¸ªframe of referenceä¸­çš„seriesè¿›è¡Œæ”¾ç½®ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¯¹æ‰«ææ•°æ®è¿›è¡Œé‡å»º

# äºŒã€åˆ‡ç‰‡

è¿™é‡Œè¯´çš„åˆ‡ç‰‡å°±æ˜¯MPR(Multi-Planar Reconstruction)ï¼Œä¸è¿‡MPRæœ‰ä¸¤ç§çŠ¶æ€ï¼šç¬¬ä¸€ç§æ˜¯åˆå§‹åŒ–é˜¶æ®µçš„è½´å¯¹é½åˆ‡ç‰‡ï¼Œè¿™ç§æ–¹å¼éœ€è¦æ‰¾åˆ°å›¾åƒçš„ä¸‰ä¸ªä¸»è½´ï¼Œç„¶ååœ¨ä¸‰ä¸ªä¸»è½´ä¸Šè¿›è¡Œåˆ‡ç‰‡ï¼Œè¿™ç§æ–¹å¼ä¸æ¶‰åŠåˆ°sliceçš„é‡æ–°é‡‡æ ·ï¼Œä¿¡æ¯ä¹Ÿä¸éœ€è¦åšä»»ä½•çš„å˜æ¢(spacing, extent)ï¼›ç¬¬äºŒç§å°±æ˜¯ä»»æ„è½´(oblique)åˆ‡ç‰‡ï¼Œè¿™ç§æ–¹å¼ä¸‹sliceä¼šè¿›è¡Œé‡é‡‡æ ·ï¼Œä¸ºäº†é¿å…å‡ºç°é‡‡æ ·æ¼æ´éœ€è¦æ ¹æ®sliceçš„é‡‡æ ·çŠ¶æ€é¢å¤–è®¡ç®—spacingå’Œextentï¼Œä»¥ä¾¿å¾—åˆ°é‡‡æ ·é—´è·ä»¥åŠé‡‡æ ·çš„èŒƒå›´

```c++
void mitk::SlicedGeometry3D::InitializePlanes(const mitk::BaseGeometry *geometry3D,
                                              mitk::PlaneGeometry::PlaneOrientation planeorientation,
                                              bool top,
                                              bool frontside,
                                              bool rotated)
{
  m_ReferenceGeometry = geometry3D;

  PlaneGeometry::Pointer planeGeometry = mitk::PlaneGeometry::New();
  planeGeometry->InitializeStandardPlane(geometry3D, top, planeorientation, frontside, rotated);

  int worldAxis =
      planeorientation == PlaneGeometry::Sagittal ? 0 :
      planeorientation == PlaneGeometry::Coronal  ? 1 : 2;

  // Inspired by:
  // http://www.na-mic.org/Wiki/index.php/Coordinate_System_Conversion_Between_ITK_and_Slicer3

  mitk::AffineTransform3D::MatrixType matrix = geometry3D->GetIndexToWorldTransform()->GetMatrix();
  matrix.GetVnlMatrix().normalize_columns();
  mitk::AffineTransform3D::MatrixType::InternalMatrixType inverseMatrix = matrix.GetTranspose();

  int dominantAxis = planeGeometry->CalculateDominantAxes(inverseMatrix).at(worldAxis);
  ScalarType viewSpacing = geometry3D->GetSpacing()[dominantAxis];

  /// Although the double value returned by GetExtent() holds a round number,
  /// you need to add 0.5 to safely convert it to unsigned it. I have seen a
  /// case when the result was less by one without this.
  auto slices = static_cast<unsigned int>(geometry3D->GetExtent(dominantAxis) + 0.5);
  if ( slices == 0 && geometry3D->GetExtent(dominantAxis) > 0) {
      // require at least one slice if there is _some_ extent
      slices = 1;
  }

  this->InitializeEvenlySpaced(planeGeometry, viewSpacing, slices);

```

## 2.1 è½´å¯¹é½åˆ‡ç‰‡

1. åœ¨æ‚£è€…åæ ‡ç³»å’Œå›¾åƒçš„ä¸–ç•Œåæ ‡ç³»ä¸é‡åˆçš„æƒ…å†µä¸‹è®¡ç®—æ ‡å‡†è§†å›¾ä¸‹çš„åˆ‡ç‰‡æ–¹å‘

åœ¨åŒ»å­¦å›¾åƒæ‰«æä¸­æ‰«é¢ç»“æœå¹¶ä¸æ€»æ˜¯å’Œä¸–ç•Œè½´é‡åˆï¼Œä¾‹å¦‚è„ŠæŸ±çš„æ‰«æè¿‡ç¨‹ä¸­ä¸ºäº†å¯¹å‡†è„ŠæŸ±çš„åˆ‡é¢ï¼ˆè„ŠæŸ±æœ‰å¯èƒ½æ˜¯å¼¯çš„ï¼‰éœ€è¦åœ¨XZå¹³é¢è¿›è¡Œç»„åˆæ‰¾åˆ°æ‰«æå¹³é¢çš„æ³•çº¿ã€‚åœ¨è½´å¯¹é½çš„MPRé‡å»ºä¸‹ï¼Œæ‚£è€…æƒ³è¦çœ‹axialè§†å›¾ä¸‹çš„åˆ‡ç‰‡ç»“æœï¼Œä½†æ˜¯æˆ‘ä»¬çš„å›¾åƒä¸–ç•Œåæ ‡ç³»å’Œä¸–ç•Œè½´æ— æ³•å®Œå…¨å¯¹åº”ä¹Ÿå°±æ— æ³•é€šè¿‡è®¾ç½®åˆ‡ç‰‡çš„æ³•å‘ä¸ºzè½´æ¥è¿›è¡Œç›´æ¥åˆ‡ç‰‡ï¼Œå› ä¸ºå›¾åƒæ˜¯æ–œç€çš„ï¼Œç›´æ¥ä½¿ç”¨zè½´è¿›è¡Œåˆ‡ç‰‡ä¼šå¯¼è‡´æ’å€¼ä»¥åŠspacingé”™è¯¯ã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°å’Œzè½´æœ€ç›¸è¿‘çš„è½´è½¬æ¢åˆ°åƒç´ åæ ‡ç³»ä¸‹è¿›è¡Œåˆ‡ç‰‡ï¼Œè¿™æ ·ä¸ä¼šå‘ç”Ÿspacingé”™è¯¯ä»¥åŠåœ¨è½´å¯¹é½æƒ…å†µä¸‹çš„åƒç´ é‡‡æ ·çš„é—®é¢˜

## 2.2 ä»»æ„å¹³é¢åˆ‡ç‰‡

### 2.2.1 in-planeå’Œthrough plane

### 2.2.2 æœ‰æ•ˆé‡‡æ ·è·ç¦»è®¡ç®—

åŒ»å­¦å›¾åƒï¼ˆå¦‚ CT/MRIï¼‰é€šå¸¸å…·æœ‰**å„å‘å¼‚æ€§ä½“ç´ é—´è·**ï¼ˆanisotropic voxel spacingï¼‰ï¼Œä¾‹å¦‚ï¼š
- In-plane: \(0.5 \times 0.5\) mmÂ²  
- Slice thickness: \(2.0\) mm  

è¿™å¯¼è‡´ï¼š
- ä¸åŒæ–¹å‘ä¸Šçš„**ç©ºé—´åˆ†è¾¨ç‡ä¸åŒ**
- åœ¨è¿›è¡Œ**æ–œåˆ‡**ï¼ˆoblique slicingï¼‰ç­‰æ“ä½œæ—¶ï¼Œè‹¥ä½¿ç”¨å›ºå®šæˆ–é”™è¯¯çš„é‡‡æ ·é—´è·ï¼Œä¼šå¯¼è‡´ï¼š
  - **æ¬ é‡‡æ ·**ï¼ˆaliasingï¼Œç»†èŠ‚ä¸¢å¤±ï¼‰
  - **è¿‡é‡‡æ ·**ï¼ˆè®¡ç®—æµªè´¹ï¼Œæ— æ–°å¢ä¿¡æ¯ï¼‰

å› æ­¤ï¼Œéœ€è¦ä¸€ç§æ–¹æ³•æ¥**åŠ¨æ€è®¡ç®—ä»»æ„æ–¹å‘ä¸Šçš„æœ‰æ•ˆé‡‡æ ·é—´è·**ã€‚

---

### 2.2.3 æ¤­çƒæ¨¡å‹çš„åŸºæœ¬åŸç†

1. å‡ ä½•å»ºæ¨¡æ€æƒ³
å°†ä½“ç´ çš„é‡‡æ ·ç‰¹æ€§å»ºæ¨¡ä¸ºä¸€ä¸ª**æ¤­çƒ**ï¼ˆellipsoidï¼‰ï¼š
\[
\frac{x^2}{s_x^2} + \frac{y^2}{s_y^2} + \frac{z^2}{s_z^2} = 1
\]
å…¶ä¸­ \( (s_x, s_y, s_z) \) æ˜¯åŸå§‹å›¾åƒåœ¨ä¸‰ä¸ªä¸»è½´æ–¹å‘çš„ç‰©ç†é—´è·ï¼ˆå•ä½ï¼šmmï¼‰ã€‚

> âœ… **æ¤­çƒè¡¨é¢è¡¨ç¤ºï¼šæ²¿ä»»æ„æ–¹å‘èƒ½åˆ†è¾¨ä¸¤ä¸ªé‡‡æ ·ç‚¹æ‰€éœ€çš„æœ€å°ç‰©ç†è·ç¦»è¾¹ç•Œã€‚**

2. æ•°å­¦æ¨å¯¼ï¼ˆå½’ä¸€åŒ–åæ ‡ç³»æ³•ï¼‰
- å°†ç‰©ç†ç©ºé—´é€šè¿‡ç¼©æ”¾å˜æ¢åˆ°**å„å‘åŒæ€§å½’ä¸€åŒ–ç©ºé—´**ï¼š
  \[
  x' = \frac{x}{s_x},\quad y' = \frac{y}{s_y},\quad z' = \frac{z}{s_z}
  \]
- åœ¨æ­¤ç©ºé—´ä¸­ï¼Œé‡‡æ ·æ˜¯å‡åŒ€çš„ï¼Œåˆ†è¾¨èƒ½åŠ›è¾¹ç•Œä¸º**å•ä½çƒ**ï¼š\(x'^2 + y'^2 + z'^2 = 1\)
- å°†ä»»æ„æ–¹å‘å‘é‡ \(\vec{d}\) æ˜ å°„å›åŸç©ºé—´ï¼Œæ±‚å…¶ä¸æ¤­çƒçš„äº¤ç‚¹è·ç¦»

3. æœ‰æ•ˆé—´è·å…¬å¼
ç»™å®šæ–¹å‘å‘é‡ \(\vec{d} = (d_x, d_y, d_z)\)ï¼Œæ²¿è¯¥æ–¹å‘çš„æœ‰æ•ˆç‰©ç†é‡‡æ ·é—´è·ä¸ºï¼š
\[
\boxed{
\text{EffectiveSpacing}(\vec{d}) = 
\frac{\|\vec{d}\|}{\sqrt{ \dfrac{d_x^2}{s_x^2} + \dfrac{d_y^2}{s_y^2} + \dfrac{d_z^2}{s_z^2} }}
}
\]

> ğŸ” ç‰¹ä¾‹éªŒè¯ï¼š
> - è‹¥ \(\vec{d} = (0,0,1)\)ï¼Œç»“æœ = \(s_z\)
> - è‹¥ \(\vec{d} = (1,1,0)\) ä¸” \(s_x = s_y\)ï¼Œç»“æœ = \(s_x\)

---

4. åœ¨ MITK ä¸­çš„å…·ä½“å®ç°

- å‡½æ•°ä½ç½®
```cpp
double mitk::SlicedGeometry3D::CalculateSpacing(
    const mitk::Vector3D &spacing,
    const mitk::Vector3D &d);
```

- å®ç°ä»£ç ï¼ˆç­‰ä»·é€»è¾‘ï¼‰
```cpp
double scaling = d[0]*d[0]/(spacing[0]*spacing[0]) +
                 d[1]*d[1]/(spacing[1]*spacing[1]) +
                 d[2]*d[2]/(spacing[2]*spacing[2]);
scaling = std::sqrt(scaling);
return std::sqrt(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]) / scaling;
```

### 2.2.4 æ±‚ä»»æ„æ–¹å‘çš„sliceä¸ªæ•°

1. ç®—æ³•ï¼šè®¡ç®—åŒ…å›´ç›’åœ¨ä»»æ„æ–¹å‘ä¸Šçš„æŠ•å½±